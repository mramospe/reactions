/*! \file
  \brief Classes and functions to work with elements from the Particle Database
  Group (PDG) and manage the database service.
*/
#pragma once

#include "reactions/database.hpp"
#include "reactions/exceptions.hpp"
#include "reactions/pow_enum.hpp"
#include "reactions/tokens.hpp"
#include "reactions/units.hpp"

#include <cmath>
#include <fstream>
#include <ios>
#include <limits>
#include <optional>
#include <tuple>
#include <vector>

namespace reactions {

  /// Define short structures that represent the fields of a \ref
  /// reactions::pdg_element object
  namespace pdg {

    /// Range of a variable in a file
    template <std::size_t Min, std::size_t Max>
    using range = reactions::database::range<Min, Max>;

    /// Range of a composite variable in a file
    template <class... R>
    using range_collection = reactions::database::range_collection<R...>;

    /// Field for the name
    struct name {
      static constexpr const char *title = "name";
      using value_type = std::string;
      using units_type = units::none;
      using range_type = range<0, 16>;
    };
    /// Field for the PDG ID
    struct pdg_id {
      static constexpr const char *title = "pdg_id";
      using value_type = int;
      using units_type = units::none;
      using range_type = range<17, 27>;
    };
    /// Field the charge multiplied by three
    struct three_charge {
      static constexpr const char *title = "three_charge";
      using value_type = int;
      using units_type = units::none;
      using range_type = range<28, 30>;
    };
    /// Field for the mass
    struct mass {
      static constexpr const char *title = "mass";
      using value_type = reactions::database::ve_double_opt;
      using units_type = units::reference<energy_units::GeV>;
      using range_type =
          range_collection<range<31, 47>, range<48, 57>, range<58, 67>>;
    };
    /// Field for the width
    struct width {
      static constexpr const char *title = "width";
      using value_type = reactions::database::ve_double_opt;
      using units_type = units::reference<energy_units::GeV>;
      using range_type =
          range_collection<range<68, 84>, range<85, 94>, range<95, 104>>;
    };
    /// Field to store the self charge-conjugate state
    struct is_self_cc {
      static constexpr const char *title = "is_self_cc";
      using value_type = bool;
      using units_type = units::none;
      using range_type = range<105, 106>;
    };

    /// Define a \ref std::tuple with the types of the fields provided
    template <class Tuple> struct underlying_types;

    /// \copydoc underlying_types
    template <class... F> struct underlying_types<std::tuple<F...>> {
      using type = std::tuple<typename F::value_type...>;
    };

    /// Base class of a PDG element
    struct base_element {

      /// Fields of the element
      using fields =
          std::tuple<name, pdg_id, three_charge, mass, width, is_self_cc>;

      /// Underlying types of the fields, as a tuple
      using type = typename underlying_types<fields>::type;

      /// Number of fields
      static constexpr auto size = std::tuple_size_v<fields>;

      /// Field type at the given index
      template <std::size_t I> using field_t = std::tuple_element_t<I, fields>;

      /// Underlying type of a field
      template <std::size_t I>
      using field_underlying_type_t = std::tuple_element_t<I, type>;

      /// Index corresponding to a given field
      template <std::size_t I, class F0, class F1> struct field_index_impl {
        static constexpr auto value = field_index_impl<
            I + 1, F0,
            std::tuple_element_t<I + 1, base_element::fields>>::value;
      };

      /// \copydoc field_index_impl
      template <std::size_t I, class F> struct field_index_impl<I, F, F> {
        static constexpr auto value = I;
      };

      /// \copydoc field_index_impl
      template <class F> struct field_index {
        static constexpr auto value = field_index_impl<
            0, F, std::tuple_element_t<0, base_element::fields>>::value;
      };

      /// \copydoc field_index
      template <class F>
      static constexpr auto field_index_v = field_index<F>::value;

      /// Size of the line (in characters) associated to this class
      static constexpr auto line_size = reactions::database::overall_range_t<
          field_t<size - 1>::range_type>::max;
    };

    /// Contain the information whether a field is optional or not
    template <class F, class Enable = void>
    struct is_optional_field : std::false_type {};

    /// \copydoc is_optional_field
    template <class F>
    struct is_optional_field<
        F, std::enable_if_t<
               reactions::database::is_optional_v<typename F::value_type>>>
        : std::true_type {};

    /// \copydoc is_optional_field
    template <class F>
    constexpr auto is_optional_field_v = is_optional_field<F>::value;

    /// Convert the given object to a string
    template <class T> std::string to_string(T const &v) {
      return std::to_string(v);
    }

    /// \copydoc to_string
    template <> std::string to_string(std::string const &v) { return v; }
  } // namespace pdg

  class pdg_system_of_units final {

  public:
    /// Get the only instance of this class
    static pdg_system_of_units &instance() {
      static pdg_system_of_units sou;
      return sou;
    }

    /// Get the energy units
    energy_units const &get_energy_units() const { return m_energy_units; }

    /// Set the energy units
    void set_energy_units(energy_units u) {

      if (u == energy_units::unknown)
        throw value_error("Setting energy units to unknown");

      m_energy_units = u;
    }

  private:
    /// Units of energy
    energy_units m_energy_units = energy_units::GeV;

    pdg_system_of_units() {}
    pdg_system_of_units(pdg_system_of_units &&) = delete;
    pdg_system_of_units(pdg_system_of_units const &) = delete;
    void operator=(pdg_system_of_units &&) = delete;
    void operator=(pdg_system_of_units const &) = delete;
  };

  namespace pdg::detail {
    /// Calculate the scale factor for a given energy field
    template <class F> auto energy_scale_factor() {
      using units_type_t = typename F::units_type;
      return units_type_t::reference::scale_factor(
          pdg_system_of_units::instance().get_energy_units());
    }

    /// Functor to process the units of a field
    template <class F, class Enable = void> struct process_units_t;

    template <class F>
    struct process_units_t<
        F, std::enable_if_t<std::is_same_v<typename F::units_type, units::none>,
                            void>> {
      template <class T>
      constexpr auto const &operator()(T const &value) const {
        return value;
      }
    };

    /// \copydoc process_units_t
    template <class F>
    struct process_units_t<
        F, std::enable_if_t<
               !std::is_same_v<typename F::units_type, units::none>, void>> {
      template <class T> constexpr auto operator()(T &&value) const {
        return energy_scale_factor<F>() * value;
      }
    };

    /// \copydoc process_units_t
    template <class F> static constexpr process_units_t<F> process_units;

    /// Return type of the accessor of a field
    template <class F, class S> struct return_type {
      using type = typename database::remove_optional_t<
          typename F::value_type>::value_type;
    };

    /// \copydoc return_type
    template <class F> struct return_type<F, void> {
      using type = database::remove_optional_t<typename F::value_type> const &;
    };

    /// \copydoc return_type
    template <class F, class S = void>
    using return_type_t = typename return_type<F, S>::type;

  } // namespace pdg::detail

  // Forward declaration
  class pdg_element;

  namespace pdg::detail {
    /// Access a field of a PDG element
    template <class F, class S = void>
    pdg::detail::return_type_t<F, S> get(pdg_element const &element) {
      if constexpr (std::is_same_v<S, void>)
        return pdg::detail::process_units<F>(
            std::get<pdg::base_element::field_index_v<F>>(element));
      else
        return pdg::detail::process_units<F>(database::get<S>(
            std::get<pdg::base_element::field_index_v<F>>(element).value()));
    }
  } // namespace pdg::detail

  /*! \brief A PDG particle, based on the fields of a particle in the PDG
   * database.
   */
  class pdg_element final : protected pdg::base_element::type {

  private:
    /*! \brief Get an element using an accessor.
     *
     * For fields of \ref std::optional type, the validity of the content
     * must be checked before calling this function using the
     * \ref pdg_element::has member function. Otherwise the
     * \ref reactions::missing_fields_error exception is thrown,
     * if missing.
     */
    template <class F, class S>
    friend pdg::detail::return_type_t<F, S>
    pdg::detail::get(pdg_element const &);

    /// Check whether the given field information is missing or not
    template <class F> constexpr bool has() const {
      if constexpr (pdg::is_optional_field_v<F>)
        return std::get<pdg::base_element::field_index_v<F>>(*this).has_value();
      else
        return true;
    }

  public:
    /// Base class
    using base_type = pdg::base_element::type;

    /// Number of data fields
    static const size_t nfields = std::tuple_size_v<base_type>;

    pdg_element() = delete;
    explicit pdg_element(pdg_element const &) = default;
    explicit pdg_element(pdg_element &&) = default;
    pdg_element &operator=(pdg_element const &) = default;

    /// Construct the element from an initializer list
    template <class... Args>
    pdg_element(Args &&... args) : base_type{std::forward<Args>(args)...} {}

    /// Construct the element from the contents
    explicit pdg_element(base_type &&tuple)
        : base_type{std::forward<base_type>(tuple)} {}

    /*! \brief Compare the ID of the two particles
     *
     * \param other element to compare with
     * \return the result of comparing the PDG IDs of the two elements
     */
    bool operator==(pdg_element const &other) const {
      return pdg_id() == other.pdg_id();
    }

    /// \copydoc pdg_element::operator==
    bool operator!=(pdg_element const &other) const {
      return pdg_id() != other.pdg_id();
    }

    /// Representation of the element name as a LaTeX string
    std::string latex_name() const {

      const auto &ref = name();
      std::size_t count = 0;
      std::size_t size = ref.size();

      if (size == 0)
        return std::string{};

      // this lambda function allows to simplify the processing of errors
      auto process_latex_string = [&]() {
        auto match_charge = [](char c) {
          return reactions::tokens::match_any<'0', '+', '-'>(c);
        };
        auto match_extra = [](char c) {
          return reactions::tokens::match_any<'*', '\''>(c);
        };
        auto match_number = [](char c) {
          return reactions::tokens::match_range<'0', '9'>(c);
        };
        auto match_lowercase = [](char c) {
          return reactions::tokens::match_range<'a', 'z'>(c);
        };
        auto match_uppercase = [](char c) {
          return reactions::tokens::match_range<'A', 'Z'>(c);
        };
        auto match_character = [](char c) {
          return reactions::tokens::match_range<'A', 'z'>(c);
        };

        std::string latex;
        std::string superscript_buffer;
        // Avoid reallocations. The constant is based on the
        // maximum size of an expansion of names to LaTeX
        // names.
        //
        // Obtained with: scripts/pdg-latex-name-buffers.py
        //
        latex.reserve(4 * ref.size());
        superscript_buffer.reserve(
            5); // maximum number of (', *, 0/+/-) in names

        // add a character or process a Greek letter
        auto process_characters = [&]() {
          latex.push_back(ref[count++]);

          if (count == size)
            return;

          if (match_lowercase(ref[count])) {
            latex.insert(latex.size() - 1, 1, '\\');
            // is a Greek letter
            do {
              latex.push_back(ref[count++]);
            } while (count < size && match_lowercase(ref[count]));
          }
        };

        // add the superscript
        auto process_superscript = [&]() {
          latex.append("^{");
          latex.insert(latex.end(), superscript_buffer.begin(),
                       superscript_buffer.end());
          superscript_buffer.clear();
          latex.push_back('}');
        };

        // ========== process the base name

        process_characters(); // first element is always a character

        if (count == size)
          return latex;

        if (reactions::tokens::match_any<'/'>(ref[count])) {

          // this is needed to process composed names like the J/psi
          latex.push_back(ref[count++]);

          if (count == size)
            return latex;

          if (match_character(ref[count]))
            process_characters();

          if (count == size)
            return latex;
        }

        // ========== process particle/anti-particle information

        if (ref.find('~') != std::string::npos) {
          // it is an anti-particle, so we must tweak the base name
          latex.insert(0, "\\bar{");
          latex.insert(latex.size(), 1, '}');
        }

        // ========== process additional qualifiers

        if (match_uppercase(ref[count])) {
          // KS0, KL0, ...
          latex.append("_{");
          do {
            latex.push_back(ref[count++]);
          } while (count < size && match_character(ref[count]));
          latex.push_back('}');

          if (count == size)
            return latex;
        }

        if (match_extra(ref[count])) {
          // first or unique superscript
          superscript_buffer.push_back(ref[count++]);
          while (count < size && match_extra(ref[count])) {
            if (reactions::tokens::match_any<'\''>(ref[count])) {
              superscript_buffer.append("\\prime");
              ++count;
            } else if (reactions::tokens::match_any<'*'>(ref[count])) {
              superscript_buffer.append("\\ast");
              ++count;
            } else
              superscript_buffer.push_back(ref[count++]);
          }

          if (count == size) {
            process_superscript();
            return latex;
          }
        }

        if (ref[count] == '_') {
          // unique subscript
          latex.push_back(ref[count++]);
          latex.push_back('{');
          while (count < size) {
            if (match_number(ref[count]))
              latex.push_back(ref[count++]);
            else if (match_character(ref[count]))
              process_characters();
            else
              break;
          }
          latex.push_back('}');

          if (count == size) {
            if (!superscript_buffer.empty())
              process_superscript();
            return latex;
          }
        }

        // ========== process the resonance mass

        if (ref[count] == '(') {

          // if there is a superscript, add it now
          if (!superscript_buffer.empty())
            process_superscript();

          // parenthesized expression
          latex.push_back(ref[count++]);
          while (count < size && ref[count] != ')')
            latex.push_back(ref[count++]);
          latex.push_back(ref[count++]); // process ')' (no check is done)

          if (count == size)
            return latex;
        }

        // ========== process the charge (skip the anti-particle token)

        if (match_charge(ref[count]) || ref[count] == '~') {
          // second superscript
          do {
            if (ref[count] == '~') // anti-particle nature is processed above
              ++count;
            else
              superscript_buffer.push_back(ref[count++]);
          } while (count < size &&
                   (match_charge(ref[count]) || ref[count] == '~'));
        }

        if (!superscript_buffer.empty())
          process_superscript();

        return latex;
      };

      auto latex = process_latex_string();

      if (count != size)
        throw reactions::internal_error(
            (std::string{"Failed to process LaTeX string for particle \""} +
             name() + "\"")
                .c_str());

      latex.shrink_to_fit();

      return latex;
    }

    /// Name of the particle
    std::string const &name() const {
      return pdg::detail::get<pdg::name>(*this);
    }

    /// PDG ID
    int pdg_id() const { return pdg::detail::get<pdg::pdg_id>(*this); }

    /// Three times the charge, as an integer
    int three_charge() const {
      return pdg::detail::get<pdg::three_charge>(*this);
    }

    /// Charge as a doubleing point number
    double charge() const {
      return pdg::detail::get<pdg::three_charge>(*this) / 3.;
    }

    /// Whether the element is its own charge-conjugate
    bool is_self_cc() const { return pdg::detail::get<pdg::is_self_cc>(*this); }

    /*! Get the mass of the element
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass() const {
      return pdg::detail::get<pdg::mass, database::value>(*this);
    }

    /// Whether the mass and its errors are defined or not
    bool has_mass() const { return has<pdg::mass>(); }

    /*! \brief Lower mass error
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error_lower() const {
      return pdg::detail::get<pdg::mass, database::error_lower>(*this);
    }

    /*! \brief Upper mass error
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error_upper() const {
      return pdg::detail::get<pdg::mass, database::error_lower>(*this);
    }

    /* \brief Calculate the mass error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error() const { return std::sqrt(mass_error_squared()); }

    /* \brief Calculate the mass error squared
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error_squared() const {

      if (!has<pdg::mass>())
        throw reactions::missing_fields_error(
            ("Unable to access mass errors; mass is not defined for particle" +
             name())
                .c_str());

      auto const el = mass_error_lower();
      auto const eu = mass_error_upper();

      return el * el + eu * eu;
    }

    /*! \brief Get the width of the element.
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width() const {
      return pdg::detail::get<pdg::width, database::value>(*this);
    }

    /// Whether the width and its errors are defined or not
    bool has_width() const { return has<pdg::width>(); }

    /*! \brief Get the lower width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error_lower() const {
      return pdg::detail::get<pdg::width, database::error_lower>(*this);
    }

    /*! \brief Get the upper width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error_upper() const {
      return pdg::detail::get<pdg::width, database::error_upper>(*this);
    }

    /*! Calculate the width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error() const { return std::sqrt(width_error_squared()); }

    /*! Calculate the width error squared
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error_squared() const {

      if (!has<pdg::width>())
        throw reactions::missing_fields_error(
            ("Unable to access width errors; width is not defined for "
             "particle" +
             name())
                .c_str());

      auto const el = width_error_lower();
      auto const eu = width_error_upper();

      return el * el + eu * eu;
    }
  };

  /*! \brief Database of elements following the PDG convention
   *
   */
  class pdg_database final {

  public:
    /*! \brief All the elements in the database file
     *
     * Calling this function does not alter the cache. If the cache is
     * enabled a copy of its content is returned. If not, elements are
     * read from the database file.
     *
     * This function returns the elements in the database and those registered
     * by the user.
     */
    std::vector<pdg_element> all_elements() const {

      std::vector<pdg_element> out;

      switch (m_cache.status()) {

      case (cache::full):

        out.insert(out.end(), m_cache.begin(), m_cache.end());
        return out;

      default:

        // open the database to count the number of lines
        auto file = open_database();

        auto start = skip_commented_lines(file);

        std::size_t count = 0;
        while (file.ignore(pdg::base_element::line_size +
                           1)) // include end-of-line
          ++count;

        file.clear(); // we reached the end of the file

        // go back to the start of the table and read the elements
        file.seekg(start);

        out.reserve(count + m_cache.size());

        for (auto i = 0u; i < count; ++i) {
          std::string line;
          std::getline(file, line);
          out.emplace_back(read_element(line));
        }

        if (m_cache.size())
          out.insert(out.end(), m_cache.begin(), m_cache.end());

        file.close();
      }

      return out;
    }

    /// Clear the cache, removing also user-registered elements
    void clear_cache() { m_cache.clear(); }

    /// Disable the cache
    void disable_cache() { m_cache.clear_database_elements(); }

    /* \brief Enable the internal cache.
     *
     * All the values in the database will be read an stored in a internal
     * cache. This will speed-up the code, with the caveat of consuming some
     * memory.
     */
    void enable_cache() {

      if (m_cache.status() == cache::full)
        return;

      // open the database to count the number of lines
      auto file = open_database();

      auto start = skip_commented_lines(file);

      std::size_t count = 0;
      while (
          file.ignore(pdg::base_element::line_size + 1)) // include end-of-line
        ++count;

      file.clear(); // we reached the end of the file

      // go back to the start of the table and read the elements
      file.seekg(start);

      std::string line;
      m_cache.add_database_elements(count,
                                    [this, &file, &line]() -> pdg_element {
                                      std::getline(file, line);
                                      return read_element(line);
                                    });

      file.close();
    }

    /// Return the charge-conjugate of an element
    pdg_element charge_conjugate(pdg_element const &el) const {

      if (el.is_self_cc())
        return el;
      else
        return operator()(-el.pdg_id());
    }

    /// Get the only instance of this class
    static pdg_database &instance() {
      static pdg_database db;
      return db;
    }

    /// Get the path to the database file
    std::string const &get_database_path() const { return m_db; }

    /*! \brief Register a new PDG element
     *
     * The new element must have a name and a PDG ID that does not clash with
     * any of the database used.
     *
     * For the LaTeX name to be valid (an to avoid possible exceptions thrown
     * during its computation), the element name must follow the following
     * convention:
     *
     * - The name starts with a set of characters. A capital letter followed by
     * lowercase letters or a set of lowercase letters are considered as a Greek
     * letter. Any capital letter following this is considered an eigenstate
     * marker (like for the two mass eigenstates of the neutral kaon), and is
     * placed as a subindex. In the latter case, no more subindices are allowed
     * in the following.
     * - Tha base name can be followed by an indicator that the particle has
     * slightly variations with respect to another existing particle or if it
     * corresponds to an excited state, in which it should be indicated with one
     * or various prime symbols for the first case, or an asterisk for the
     * second.
     * - A set of subindices can be specified afterwards, that can be characters
     * (indicating the underlying falvour) or numbers (indicating the spin),
     * preceeded by an underscore symbol.
     * - The mass can be indicated between two parentheses as an integral
     * number, and is mandatory if you are providing subindices.
     * - The last part of the name is composed by the possible anti-particle
     * marker, specified with a tilde, and the charge, which can be 0, + or -.
     *
     * There is no official naming scheme for the PDG particles, but the
     * following guidelines can be used in order to get the most common way of
     * naming the particles:
     *
     * - Quarks are specified with a single character, and anti-quarks extend
     * this name by adding a tilde.
     * - If the name refers to a gauge boson, it must only contain the charge if
     * it is named with a captial letter.
     * - Hadrons only contain the charge if there are other entries in the
     * database with the same name. In the case of mesons, they also contain the
     * charge if the particle is not self charge-conjugate.
     * - The anti-particles of mesons where the charge is in the name are
     * specified using the opposite charge. For the rest, anti-particles are
     * specified by including a tilde before the charge or at the end of the
     * name, where adecuate.
     */
    template <class... Args> void register_element(Args &&... args) {

      pdg_element new_element{std::forward<Args>(args)...};

      // If the cache is enabled, the checks are done within the cache object,
      // otherwise we must check the database
      if (m_cache.status() != cache::full) {

        auto file = open_database();

        skip_commented_lines(file);

        std::string line;

        while (std::getline(file, line)) {

          pdg::name::value_type name;
          if (reactions::database::read_field<pdg::name::range_type>(
                  name, line) == reactions::database::failed)
            throw reactions::database_error(
                "Error reading PDG database; data format not understood");

          if (new_element.name() == name)
            throw reactions::database_error(
                "Attempt to register an element with similar name to an "
                "element in the database");

          pdg::pdg_id::value_type pdg_id;
          if (reactions::database::read_field<pdg::pdg_id::range_type>(
                  pdg_id, line) == reactions::database::failed)
            throw reactions::database_error(
                "Error reading PDG database; data format not understood");

          if (new_element.pdg_id() == pdg_id)
            throw reactions::database_error(
                "Attempt to register an element with similar PDG ID to an "
                "element in the database");
        }
      }

      // this must be done after the checks are done to prevent leaving
      // the cache in an invalid state
      m_cache.add_user_element(std::move(new_element));
    }

    /* \brief Set the path to the database file.
     *
     * If the cache is enabled, reloads the content using the new path.
     */
    void set_database_path(std::string const &s) {
      m_db = s;
      if (m_cache.status() == cache::full) {
        disable_cache();
        enable_cache();
      }
    }

    /// Create an element accessing by ID
    pdg_element operator()(int id) const { return access<pdg::pdg_id>(id); }

    /// Create an element accessing by name
    pdg_element operator()(std::string const &str) const {
      return access<pdg::name>(str);
    }

  private:
    /// Path to the database file
    std::string m_db = "@PDG_TABLE@";

    /// \brief Cache of PDG elements
    class cache {

    public:
      /// Code to define the status of the cache
      enum cache_status { empty, user, full };

      using cache_type = std::vector<pdg_element>;
      using const_iterator_type = cache_type::const_iterator;
      using size_type = cache_type::size_type;

      cache() = default;

      /// Clear the cache
      void clear() {
        m_vector.clear();
        m_vector.shrink_to_fit();
        m_separator = 0;
      }

      /// Clear the cache
      void clear_database_elements() {
        m_vector.erase(database_cbegin(), database_cend());
        m_vector.shrink_to_fit();
        m_separator = 0;
      }

      /// Status of the cache
      cache_status status() const {
        if (m_vector.size()) {
          if (database_size() == 0)
            return cache_status::user;
          else
            return cache_status::full;
        } else
          return cache_status::empty;
      }

      /// Underlying vector of elements
      cache_type const &elements() const { return m_vector; }

      /// Underlying vector of elements
      cache_type &elements() { return m_vector; }

      /// Begining of the cache
      const_iterator_type begin() const { return m_vector.cbegin(); }

      /// End of the cache
      const_iterator_type end() const { return m_vector.cend(); }

      /// Begining of the database elements
      const_iterator_type database_cbegin() const { return m_vector.cbegin(); }

      /// End of the database elements
      const_iterator_type database_cend() const {
        return m_vector.cbegin() + m_separator;
      }

      /// Begining of the user-registered elements
      const_iterator_type user_registered_cbegin() const {
        return database_cend();
      }

      /// End of the user-registered elements
      const_iterator_type user_registered_cend() const {
        return m_vector.cend();
      }

      /// Number of elements associated to the database
      size_type database_size() const { return m_separator; }

      /// Number of user-registered elements
      size_type user_registered_size() const {
        return m_vector.size() - m_separator;
      }

      /// Number of cached elements
      size_type size() const { return m_vector.size(); }

      /// Add elements from a database by calling the given function several
      /// times
      template <class ElementReader>
      void add_database_elements(size_type n, ElementReader func) {

        cache_type new_cache;
        new_cache.reserve(n + user_registered_size());

        for (auto i = 0u; i < n; ++i) {

          auto new_element = func();

          // check that we do not repeat any entry
          if (user_registered_size() != 0) {
            auto cend = user_registered_cend();
            if (std::find_if(user_registered_cbegin(), cend,
                             [&new_element](pdg_element const &el) {
                               return (el.name() == new_element.name() ||
                                       el.pdg_id() == new_element.pdg_id());
                             }) != cend)
              throw reactions::database_error(
                  (std::string{"User-defined element clashes with database "
                               "element: \""} +
                   new_cache.back().name() + "\"")
                      .c_str());
          }

          new_cache.emplace_back(std::move(new_element));
        }

        // insert the elements and assign the separator to the number of
        // database elements
        new_cache.insert(new_cache.end(),
                         std::make_move_iterator(user_registered_cbegin()),
                         std::make_move_iterator(user_registered_cend()));
        m_separator = n;
        m_vector = std::move(new_cache);
      }

      /// Add a new element (by the user)
      template <class... Args>
      pdg_element const &add_user_element(Args &&... args) {
        pdg_element new_element{std::forward<Args>(args)...};
        auto e = end();
        if (std::find_if(begin(), e,
                         [this, &new_element](pdg_element const &el) {
                           return (el.name() == new_element.name() ||
                                   el.pdg_id() == new_element.pdg_id());
                         }) != e) {
          throw reactions::database_error(
              (std::string{"User-registered element clashes: \""} +
               new_element.name() + "\"")
                  .c_str());
        }
        m_vector.emplace_back(std::move(new_element));
        return m_vector.back();
      }

    protected:
      /// Collection of elements
      cache_type m_vector;

      /// Index that defines elements registered by the user and those read from
      /// the database
      size_type m_separator = 0;

    } m_cache; /// Cache for elements loaded from the database or registered by
               /// the user

    /// Open the database
    std::ifstream open_database() const {

      if (m_db.empty())
        throw reactions::database_error(
            "The PDG database has not been specified");

      std::ifstream file;

      try {
        file.open(m_db);
      } catch (...) {
        throw reactions::database_error("Unable to access the database");
      }

      if (!file.is_open())
        throw reactions::database_error("Unable to access the database");

      return file;
    }

    /// Skip lines with comments (preceeded by *)
    std::streampos skip_commented_lines(std::ifstream &file) const {

      char c;
      while (true) {
        file.get(c);
        if (c == '*')
          file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        else
          break;
      }
      file.unget();

      return file.tellg();
    }

    /// Read a field with the given index from a line
    template <std::size_t I>
    bool read_field(pdg_element::base_type &tuple,
                    std::string const &line) const {

      using field = pdg::base_element::field_t<I>;

      if constexpr (pdg::is_optional_field_v<field>) {

        typename field::value_type::value_type value;

        auto sc = reactions::database::read_field<typename field::range_type>(
            value, line);

        if (sc == reactions::database::conversion_status::success)
          std::get<I>(tuple).emplace(value);

        return sc != reactions::database::conversion_status::failed;
      } else
        return reactions::database::read_field<typename field::range_type>(
                   std::get<I>(tuple), line) !=
               reactions::database::conversion_status::failed;
    }

    /// Read all the fields from a line
    template <std::size_t... I>
    bool read_line(pdg_element::base_type &tuple, std::string const &line,
                   std::index_sequence<I...>) const {
      return (read_field<I>(tuple, line) && ...);
    }

    /// Read all the fields from a line
    bool read_line(pdg_element::base_type &tuple,
                   std::string const &line) const {
      return read_line(tuple, line,
                       std::make_index_sequence<pdg_element::nfields>());
    }

    /// Advance to the next element in the file and read it
    pdg_element read_element(std::string const &line) const {

      pdg_element::base_type tuple;

      if (!read_line(tuple, line))
        throw reactions::database_error(
            "Error reading PDG database; data format not understood");

      return tuple;
    }

    /// Access an element using the field accessor
    template <class F, class T> pdg_element access(T const &v) const {

      switch (m_cache.status()) {
      case (cache::full): // the full database is loaded

        for (auto const &el : m_cache)
          if (pdg::detail::get<F>(el) == v)
            return el;

        break; // throws an exception

      case (cache::user): // only user-registered entries exist

        for (auto const &el : m_cache)
          if (pdg::detail::get<F>(el) == v)
            return el;

        [[fallthrough]]; // continue as if we had no cache

      case (cache::empty): // the cache is empty

        auto file = open_database();

        skip_commented_lines(file);

        std::string line;

        while (std::getline(file, line)) {

          typename F::value_type ref;
          auto sc = reactions::database::read_field<typename F::range_type>(
              ref, line);

          if (sc == reactions::database::failed)
            throw reactions::database_error(
                "Error reading PDG database; data format not understood");

          if (ref == v) {
            pdg_element el = read_element(line);
            file.close();
            return el;
          }
        }

        file.close();
      }

      throw reactions::lookup_error(
          (std::string{"Unable to find element with "} + F::title + " \"" +
           pdg::to_string(v) + '"')
              .c_str());
    }

    pdg_database() {}
    pdg_database(pdg_database &&) = delete;
    pdg_database(pdg_database const &) = delete;
    void operator=(pdg_database &&) = delete;
    void operator=(pdg_database const &) = delete;
  };
} // namespace reactions
