/*! \file
  \brief Classes and functions to work with elements from the Particle Database
  Group (PDG) and manage the database service.
*/
#pragma once

#include "reactions/database.hpp"
#include "reactions/exceptions.hpp"
#include "reactions/pow_enum.hpp"
#include "reactions/tokens.hpp"
#include "reactions/units.hpp"
#include "reactions/utils.hpp"

#include <cmath>
#include <fstream>
#include <ios>
#include <limits>
#include <optional>
#include <tuple>
#include <vector>

namespace reactions {

  /// Structures representing the fields of a \ref reactions::pdg_element object
  namespace pdg {

    /// Range of a variable in a file
    template <std::size_t Min, std::size_t Max>
    using range = reactions::database::range<Min, Max>;

    /// Range of a composite variable in a file
    template <class... R>
    using range_collection = reactions::database::range_collection<R...>;

    /// Field for the name
    struct name {
      static constexpr const char *title = "name";
      using value_type = std::string;
      using units_type = units::none;
      using range_type = range<0, 18>;
    };
    /// Field for the PDG ID
    struct pdg_id {
      static constexpr const char *title = "pdg_id";
      using value_type = int;
      using units_type = units::none;
      using range_type = range<19, 29>;
    };
    /// Field the charge multiplied by three
    struct three_charge {
      static constexpr const char *title = "three_charge";
      using value_type = int;
      using units_type = units::none;
      using range_type = range<30, 32>;
    };
    /// Field for the mass
    struct mass {
      static constexpr const char *title = "mass";
      using value_type = reactions::database::ve_double_opt;
      using units_type = units::reference<energy_units::GeV>;
      using range_type =
          range_collection<range<33, 49>, range<50, 59>, range<60, 69>>;
    };
    /// Field for the width
    struct width {
      static constexpr const char *title = "width";
      using value_type = reactions::database::ve_double_opt;
      using units_type = units::reference<energy_units::GeV>;
      using range_type =
          range_collection<range<70, 86>, range<87, 96>, range<97, 106>>;
    };
    /// Field to store the self charge-conjugate state
    struct is_self_cc {
      static constexpr const char *title = "is_self_cc";
      using value_type = bool;
      using units_type = units::none;
      using range_type = range<107, 108>;
    };

    /// Convert the given object to a string
    template <class T> std::string to_string(T const &v) {
      return std::to_string(v);
    }

    /// \copydoc to_string
    template <> std::string to_string(std::string const &v) { return v; }
  } // namespace pdg

  /*! \brief Defines a singleton to handle the units of PDG elements
   *
   * This class affects the values returned by the \ref pdg_element
   * objects, scaling them according to the units defined by the user.
   */
  class pdg_system_of_units final {

  public:
    /// Get the only instance of this class
    static pdg_system_of_units &instance() {
      static pdg_system_of_units sou;
      return sou;
    }

    /// Get the energy units
    energy_units const &get_energy_units() const { return m_energy_units; }

    /// Set the energy units
    void set_energy_units(energy_units u) {

      if (u == energy_units::unknown)
        throw value_error("Setting energy units to unknown");

      m_energy_units = u;
    }

  private:
    /// Units of energy
    energy_units m_energy_units = energy_units::GeV;

    pdg_system_of_units() {}
    pdg_system_of_units(pdg_system_of_units &&) = delete;
    pdg_system_of_units(pdg_system_of_units const &) = delete;
    void operator=(pdg_system_of_units &&) = delete;
    void operator=(pdg_system_of_units const &) = delete;
  };

  /// Internal utilities for the \ref reactions::pdg namespace
  namespace pdg::detail {
    /// Calculate the scale factor for a given energy field
    template <class F> auto energy_scale_factor() {
      using units_type_t = typename F::units_type;
      return units_type_t::reference::scale_factor(
          pdg_system_of_units::instance().get_energy_units());
    }

    /// Functor to process the units of a field
    template <class F, class Enable = void> struct process_units_t;

    /// \copydoc process_units_t
    template <class F>
    struct process_units_t<
        F, std::enable_if_t<std::is_same_v<typename F::units_type, units::none>,
                            void>> {
      template <class T>
      constexpr auto const &operator()(T const &value) const {
        if constexpr (database::is_optional_v<std::decay_t<T>>)
          return value.value();
        else
          return value;
      }
    };

    /// \copydoc process_units_t
    template <class F>
    struct process_units_t<
        F, std::enable_if_t<
               !std::is_same_v<typename F::units_type, units::none>, void>> {
      template <class T> constexpr auto operator()(T &&value) const {
        if constexpr (database::is_optional_v<std::decay_t<T>>)
          return energy_scale_factor<F>() * value.value();
        else
          return energy_scale_factor<F>() * value;
      }
    };

    /// \copydoc process_units_t
    template <class F> static constexpr process_units_t<F> process_units;

    /// Determine the type to be returned after processing the units of a field
    template <class F, class T, class Enable = void>
    struct return_type_after_parsing_units {
      using type = std::decay_t<database::remove_optional_t<T>>;
    };

    /// \copydoc return_type_after_parsing_units
    template <class F, class T>
    struct return_type_after_parsing_units<
        F, T,
        std::enable_if_t<std::is_same_v<typename F::units_type, units::none>>> {
      using type = std::decay_t<database::remove_optional_t<T>> const &;
    };

    /// \copydoc return_type_after_parsing_units
    template <class F, class T>
    using return_type_after_parsing_units_t =
        typename return_type_after_parsing_units<F, T>::type;

    /// Acess the subtype of a set of fields
    template <class F, class... S> struct field_subtype;

    /// \copydoc field_subtype
    template <class F, class S0, class... S> struct field_subtype<F, S0, S...> {
      using type = typename field_subtype<
          typename database::remove_optional_t<F>::value_type, S...>::type;
    };

    /// \copydoc field_subtype
    template <class F> struct field_subtype<F> {
      using type = database::remove_optional_t<F>;
    };

    /// \copydoc field_subtype
    template <class F, class... S>
    using field_subtype_t = typename field_subtype<F, S...>::type;

    /// Return type of the accessor of a field
    template <class F, class... S> struct return_type {
      using type = return_type_after_parsing_units_t<
          F, field_subtype_t<typename F::value_type, S...>>;
    };

    /// \copydoc return_type
    template <class F, class... S>
    using return_type_t = typename return_type<F, S...>::type;

    /// Object to access fields
    template <class F, class... S> struct accessor_t;

    /// Static object to access the fields of a tuple-like object
    template <class F, class... S>
    static constexpr accessor_t<F, S...> accessor;

    /// \copydoc accessor_t
    template <class F> struct accessor_t<F> {
      /// Access a value and process the units
      template <class T>
      constexpr return_type_after_parsing_units_t<F, T>
      operator()(T const &f) const {
        return process_units<F>(f);
      }
    };

    /// \copydoc accessor_t
    template <class F, class S0, class... S> struct accessor_t<F, S0, S...> {
      /// \copydoc accessor_t::operator()
      template <class T>
      constexpr return_type_t<F, S0, S...> operator()(T const &f) const {

        if constexpr (database::is_optional_v<T>)
          return accessor<F, S...>(database::get<S0>(f.value()));
        else
          return accessor<F, S...>(database::get<S0>(f));
      }
    };

  } // namespace pdg::detail

  /// Field types of a PDG element
  using pdg_element_fields =
      std::tuple<pdg::name, pdg::pdg_id, pdg::three_charge, pdg::mass,
                 pdg::width, pdg::is_self_cc>;

  /// Base class of a PDG element
  using pdg_element_base =
      typename database::underlying_types<pdg_element_fields>::type;

  /*! \brief A PDG particle, based on the fields of a particle in the PDG
   * database.
   */
  class pdg_element final : protected pdg_element_base {

  public:
    /// Base class
    using base_type = pdg_element_base;

    /// Fields of the element
    using fields = pdg_element_fields;

    /// Number of data fields
    static const size_t number_of_fields = std::tuple_size_v<base_type>;

    /// Size of the line (in characters) associated to this class
    static constexpr auto line_size = reactions::database::overall_range_t<
        std::tuple_element_t<number_of_fields - 1, fields>::range_type>::max;

    pdg_element() = delete;
    explicit pdg_element(pdg_element const &) = default;
    explicit pdg_element(pdg_element &&) = default;
    pdg_element &operator=(pdg_element const &) = default;

    /// Construct the element from an initializer list
    template <class... Args>
    pdg_element(Args &&... args) : base_type{std::forward<Args>(args)...} {}

    /// Construct the element from the contents
    explicit pdg_element(base_type &&tuple)
        : base_type{std::forward<base_type>(tuple)} {}

    /*! \brief Compare the ID of the two particles
     *
     * \param other element to compare with
     * \return the result of comparing the PDG IDs of the two elements
     */
    bool operator==(pdg_element const &other) const {
      return pdg_id() == other.pdg_id();
    }

    /// \copydoc pdg_element::operator==
    bool operator!=(pdg_element const &other) const {
      return pdg_id() != other.pdg_id();
    }

    /*! \brief Get an element using an accessor.
     *
     * For fields of \ref std::optional type, the validity of the content
     * must be checked before calling this function using the
     * \ref pdg_element::has member function. Otherwise the
     * \ref reactions::missing_fields_error exception is thrown,
     * if missing.
     *
     * The return type is a constant reference for values without units and
     * a value for those with units.
     */
    template <class F, class... S>
    pdg::detail::return_type_t<F, S...> get() const {
      return pdg::detail::accessor<F, S...>(
          std::get<utils::tuple_index_v<fields, F>>(*this));
    }

    /// Check whether the given field information is missing or not
    template <class F> constexpr bool has() const {
      if constexpr (database::is_optional_field_v<F>)
        return std::get<utils::tuple_index_v<fields, F>>(*this).has_value();
      else
        return true;
    }

    /// Representation of the element name as a LaTeX string
    std::string latex_name() const {

      const auto &ref = name();
      std::size_t count = 0;
      std::size_t size = ref.size();

      if (size == 0)
        return std::string{};

      // this lambda function allows to simplify the processing of errors
      auto process_latex_string = [&]() {
        auto match_charge = [](char c) {
          return reactions::tokens::match_any<'0', '+', '-'>(c);
        };
        auto match_extra = [](char c) {
          return reactions::tokens::match_any<'*', '\''>(c);
        };
        auto match_number = [](char c) {
          return reactions::tokens::match_range<'0', '9'>(c);
        };
        auto match_lowercase = [](char c) {
          return reactions::tokens::match_range<'a', 'z'>(c);
        };
        auto match_character = [](char c) {
          return reactions::tokens::match_range<'A', 'z'>(c);
        };

        std::string latex;
        std::string superscript_buffer;
        // Avoid reallocations. The constant is based on the
        // maximum size of an expansion of names to LaTeX
        // names.
        //
        // Obtained with: scripts/pdg-latex-name-buffers.py
        //
        latex.reserve(4 * ref.size());
        superscript_buffer.reserve(
            5); // maximum number of (', *, 0/+/-) in names

        // add a character or process a Greek letter
        auto process_characters = [&]() {
          latex.push_back(ref[count++]);

          if (count == size)
            return;

          if (match_lowercase(ref[count])) {
            latex.insert(latex.size() - 1, 1, '\\');
            // is a Greek letter
            do {
              latex.push_back(ref[count++]);
            } while (count < size && match_lowercase(ref[count]));
          }
        };

        // add the superscript
        auto process_superscript = [&]() {
          latex.append("^{");
          latex.insert(latex.end(), superscript_buffer.begin(),
                       superscript_buffer.end());
          superscript_buffer.clear();
          latex.push_back('}');
        };

        // ========== process the base name

        process_characters(); // first element is always a character

        if (count == size)
          return latex;

        if (reactions::tokens::match_any<'/'>(ref[count])) {

          // this is needed to process composed names like the J/psi
          latex.push_back(ref[count++]);

          if (count == size)
            return latex;

          if (match_character(ref[count]))
            process_characters();

          if (count == size)
            return latex;
        }

        // ========== process particle/anti-particle information

        if (ref.find('~') != std::string::npos) {
          // it is an anti-particle, so we must tweak the base name
          latex.insert(0, "\\bar{");
          latex.insert(latex.size(), 1, '}');
        }

        // ========== process additional qualifiers

        if (ref[count] == '(' &&
            (!match_number(ref[count + 1]) ||
             ref.find('(', count + 1) != std::string::npos)) {
          // unique subscript
          latex.insert(latex.size(), "_{");
          ++count;
          while (ref[count] != ')') {

            if (match_character(ref[count]))
              process_characters(); // increments the counter
            else
              latex.push_back(ref[count++]);

            if (count == size)
              throw internal_error("Missing parenthesis in name");
          }

          latex.push_back('}');

          if (++count == size) { // process the parenthesis
            if (!superscript_buffer.empty())
              process_superscript();
            return latex;
          }
        }

        if (match_extra(ref[count])) {
          // first or unique superscript
          superscript_buffer.push_back(ref[count++]);
          while (count < size && match_extra(ref[count])) {
            if (reactions::tokens::match_any<'\''>(ref[count])) {
              superscript_buffer.append("\\prime");
              ++count;
            } else if (reactions::tokens::match_any<'*'>(ref[count])) {
              superscript_buffer.append("\\ast");
              ++count;
            } else
              superscript_buffer.push_back(ref[count++]);
          }

          if (count == size) {
            process_superscript();
            return latex;
          }
        }

        // ========== process the resonance mass

        if (ref[count] == '(') {

          // if there is a superscript, add it now
          if (!superscript_buffer.empty())
            process_superscript();

          // parenthesized expression
          latex.push_back(ref[count++]);
          while (ref[count] != ')') {
            latex.push_back(ref[count++]);
            if (count == size)
              throw internal_error("Missing parenthesis in name");
          }
          latex.push_back(ref[count++]); // process ')' (no check is done)

          if (count == size)
            return latex;
        }

        // ========== process the charge (skip the anti-particle token)

        if (match_charge(ref[count]) || ref[count] == '~') {
          // second superscript
          do {
            if (ref[count] == '~') // anti-particle nature is processed above
              ++count;
            else
              superscript_buffer.push_back(ref[count++]);
          } while (count < size &&
                   (match_charge(ref[count]) || ref[count] == '~'));
        }

        if (!superscript_buffer.empty())
          process_superscript();

        return latex;
      };

      auto latex = process_latex_string();

      if (count != size)
        throw reactions::internal_error(
            (std::string{"Failed to process LaTeX string for particle \""} +
             name() + "\"")
                .c_str());

      latex.shrink_to_fit();

      return latex;
    }

    /// Name of the particle
    std::string const &name() const { return get<pdg::name>(); }

    /// PDG ID
    int pdg_id() const { return get<pdg::pdg_id>(); }

    /// Three times the charge, as an integer
    int three_charge() const { return get<pdg::three_charge>(); }

    /// Charge as a doubleing point number
    double charge() const { return get<pdg::three_charge>() / 3.; }

    /// Whether the element is its own charge-conjugate
    bool is_self_cc() const { return get<pdg::is_self_cc>(); }

    /*! Get the mass of the element
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass() const { return get<pdg::mass, database::value>(); }

    /// Whether the mass and its errors are defined or not
    bool has_mass() const { return has<pdg::mass>(); }

    /*! \brief Lower mass error
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error_lower() const {
      return get<pdg::mass, database::error_lower>();
    }

    /*! \brief Upper mass error
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error_upper() const {
      return get<pdg::mass, database::error_lower>();
    }

    /* \brief Calculate the mass error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error() const { return std::sqrt(mass_error_squared()); }

    /* \brief Calculate the mass error squared
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double mass_error_squared() const {

      if (!has<pdg::mass>())
        throw reactions::missing_fields_error(
            ("Unable to access mass errors; mass is not defined for particle" +
             name())
                .c_str());

      auto const el = mass_error_lower();
      auto const eu = mass_error_upper();

      return el * el + eu * eu;
    }

    /*! \brief Get the width of the element.
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width() const { return get<pdg::width, database::value>(); }

    /// Whether the width and its errors are defined or not
    bool has_width() const { return has<pdg::width>(); }

    /*! \brief Get the lower width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error_lower() const {
      return get<pdg::width, database::error_lower>();
    }

    /*! \brief Get the upper width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error_upper() const {
      return get<pdg::width, database::error_upper>();
    }

    /*! Calculate the width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error() const { return std::sqrt(width_error_squared()); }

    /*! Calculate the width error squared
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::missing_fields_error is thrown.
     */
    double width_error_squared() const {

      if (!has<pdg::width>())
        throw reactions::missing_fields_error(
            ("Unable to access width errors; width is not defined for "
             "particle" +
             name())
                .c_str());

      auto const el = width_error_lower();
      auto const eu = width_error_upper();

      return el * el + eu * eu;
    }
  };

  /*! \brief Database of elements following the PDG convention
   *
   */
  class pdg_database final {

  public:
    /*! \brief All the elements in the database file
     *
     * Calling this function does not alter the cache. If the cache is
     * enabled a copy of its content is returned. If not, elements are
     * read from the database file.
     *
     * This function returns the elements in the database and those registered
     * by the user.
     */
    std::vector<pdg_element> all_elements() const {

      std::vector<pdg_element> out;

      switch (m_cache.status()) {

      case (cache::full):

        out.insert(out.end(), m_cache.begin(), m_cache.end());
        return out;

      default:

        // open the database to count the number of lines
        auto file = open_database();

        auto start = skip_commented_lines(file);

        std::size_t count = 0;
        while (file.ignore(pdg_element::line_size + 1)) // include end-of-line
          ++count;

        file.clear(); // we reached the end of the file

        // go back to the start of the table and read the elements
        file.seekg(start);

        out.reserve(count + m_cache.size());

        for (auto i = 0u; i < count; ++i) {
          std::string line;
          std::getline(file, line);
          out.emplace_back(read_element(line));
        }

        if (m_cache.size())
          out.insert(out.end(), m_cache.begin(), m_cache.end());

        file.close();
      }

      return out;
    }

    /// Clear the cache, removing also user-registered elements
    void clear_cache() { m_cache.clear(); }

    /// Disable the cache
    void disable_cache() { m_cache.clear_database_elements(); }

    /* \brief Enable the internal cache.
     *
     * All the values in the database will be read an stored in a internal
     * cache. This will speed-up the code, with the caveat of consuming some
     * memory.
     */
    void enable_cache() {

      if (m_cache.status() == cache::full)
        return;

      // open the database to count the number of lines
      auto file = open_database();

      auto start = skip_commented_lines(file);

      std::size_t count = 0;
      while (file.ignore(pdg_element::line_size + 1)) // include end-of-line
        ++count;

      file.clear(); // we reached the end of the file

      // go back to the start of the table and read the elements
      file.seekg(start);

      std::string line;
      m_cache.add_database_elements(count,
                                    [this, &file, &line]() -> pdg_element {
                                      std::getline(file, line);
                                      return read_element(line);
                                    });

      file.close();
    }

    /// Return the charge-conjugate of an element
    pdg_element charge_conjugate(pdg_element const &el) const {

      if (el.is_self_cc())
        return el;
      else
        return operator()(-el.pdg_id());
    }

    /// Get the only instance of this class
    static pdg_database &instance() {
      static pdg_database db;
      return db;
    }

    /// Get the path to the database file
    std::string const &get_database_path() const { return m_db; }

    /*! \brief Register a new PDG element
     *
     * The new element must have a name and a PDG ID that does not clash with
     * any of the database used.
     *
     * For the LaTeX name to be valid (an to avoid possible exceptions thrown
     * during its computation), the element name must follow the following
     * convention:
     *
     * - The name starts with a set of characters. A capital letter followed by
     * lowercase letters or a set of lowercase letters are considered as a Greek
     * letter.
     * - The base name can be followed by a set of modifiers indicating the
     * flavour, mass eigenstate or spin of the particle, between parenthesis.
     * - After, it is possible to indicate that the particle has a sligh
     * variation with respect to another existing particle or that it
     * corresponds to an excited state, in which it should be indicated with one
     * or various prime symbols for the first case, or an asterisk for the
     * second.
     * - The mass can be indicated between two parentheses as an integral
     * number.
     * - The last part of the name is composed by the possible anti-particle
     * marker, specified with a tilde, and the charge, which can be 0, + or -.
     *
     * There is no official naming scheme for the PDG particles, but the
     * following guidelines can be used in order to get the most common way of
     * naming the particles:
     *
     * - Quarks are specified with a single character, and anti-quarks extend
     * this name by adding a tilde.
     * - If the name refers to a gauge boson, it must only contain the charge if
     * it is named with a captial letter.
     * - Hadrons only contain the charge if there are other entries in the
     * database with the same name. In the case of mesons, they also contain the
     * charge if the particle is not self charge-conjugate.
     * - Particle names referring to mass-eigenstates contain the charge if
     * the corresponding flavour eigenstates do.
     * - The anti-particles of mesons where the charge is in the name are
     * specified using the opposite charge. For the rest, anti-particles are
     * specified by including a tilde before the charge or at the end of the
     * name, where adecuate.
     */
    template <class... Args> void register_element(Args &&... args) {

      pdg_element new_element{std::forward<Args>(args)...};

      // If the cache is enabled, the checks are done within the cache object,
      // otherwise we must check the database
      if (m_cache.status() != cache::full) {

        auto file = open_database();

        skip_commented_lines(file);

        std::string line;

        while (std::getline(file, line)) {

          pdg::name::value_type name;
          if (reactions::database::read_field<pdg::name::range_type>(
                  name, line) == reactions::database::failed)
            throw reactions::database_error(
                "Error reading PDG database; data format not understood");

          if (new_element.name() == name)
            throw reactions::database_error(
                "Attempt to register an element with similar name to an "
                "element in the database");

          pdg::pdg_id::value_type pdg_id;
          if (reactions::database::read_field<pdg::pdg_id::range_type>(
                  pdg_id, line) == reactions::database::failed)
            throw reactions::database_error(
                "Error reading PDG database; data format not understood");

          if (new_element.pdg_id() == pdg_id)
            throw reactions::database_error(
                "Attempt to register an element with similar PDG ID to an "
                "element in the database");
        }
      }

      // this must be done after the checks are done to prevent leaving
      // the cache in an invalid state
      m_cache.add_user_element(std::move(new_element));
    }

    /* \brief Set the path to the database file.
     *
     * If the cache is enabled, reloads the content using the new path.
     */
    void set_database_path(std::string const &s) {
      m_db = s;
      if (m_cache.status() == cache::full) {
        disable_cache();
        enable_cache();
      }
    }

    /// Create an element accessing by ID
    pdg_element operator()(int id) const { return access<pdg::pdg_id>(id); }

    /// Create an element accessing by name
    pdg_element operator()(std::string const &str) const {
      return access<pdg::name>(str);
    }

  private:
    /// Path to the database file
    std::string m_db = "@PDG_TABLE@";

    /// \brief Cache of PDG elements
    class cache {

    public:
      /// Code to define the status of the cache
      enum cache_status { empty, user, full };

      using cache_type = std::vector<pdg_element>;
      using const_iterator_type = cache_type::const_iterator;
      using size_type = cache_type::size_type;

      cache() = default;

      /// Clear the cache
      void clear() {
        m_vector.clear();
        m_vector.shrink_to_fit();
        m_separator = 0;
      }

      /// Clear the cache
      void clear_database_elements() {
        m_vector.erase(database_cbegin(), database_cend());
        m_vector.shrink_to_fit();
        m_separator = 0;
      }

      /// Status of the cache
      cache_status status() const {
        if (m_vector.size()) {
          if (database_size() == 0)
            return cache_status::user;
          else
            return cache_status::full;
        } else
          return cache_status::empty;
      }

      /// Underlying vector of elements
      cache_type const &elements() const { return m_vector; }

      /// Underlying vector of elements
      cache_type &elements() { return m_vector; }

      /// Begining of the cache
      const_iterator_type begin() const { return m_vector.cbegin(); }

      /// End of the cache
      const_iterator_type end() const { return m_vector.cend(); }

      /// Begining of the database elements
      const_iterator_type database_cbegin() const { return m_vector.cbegin(); }

      /// End of the database elements
      const_iterator_type database_cend() const {
        return m_vector.cbegin() + m_separator;
      }

      /// Begining of the user-registered elements
      const_iterator_type user_registered_cbegin() const {
        return database_cend();
      }

      /// End of the user-registered elements
      const_iterator_type user_registered_cend() const {
        return m_vector.cend();
      }

      /// Number of elements associated to the database
      size_type database_size() const { return m_separator; }

      /// Number of user-registered elements
      size_type user_registered_size() const {
        return m_vector.size() - m_separator;
      }

      /// Number of cached elements
      size_type size() const { return m_vector.size(); }

      /// Add elements from a database by calling the given function several
      /// times
      template <class ElementReader>
      void add_database_elements(size_type n, ElementReader func) {

        cache_type new_cache;
        new_cache.reserve(n + user_registered_size());

        for (auto i = 0u; i < n; ++i) {

          auto new_element = func();

          // check that we do not repeat any entry
          if (user_registered_size() != 0) {
            auto cend = user_registered_cend();
            if (std::find_if(user_registered_cbegin(), cend,
                             [&new_element](pdg_element const &el) {
                               return (el.name() == new_element.name() ||
                                       el.pdg_id() == new_element.pdg_id());
                             }) != cend)
              throw reactions::database_error(
                  (std::string{"User-defined element clashes with database "
                               "element: \""} +
                   new_cache.back().name() + "\"")
                      .c_str());
          }

          new_cache.emplace_back(std::move(new_element));
        }

        // insert the elements and assign the separator to the number of
        // database elements
        new_cache.insert(new_cache.end(),
                         std::make_move_iterator(user_registered_cbegin()),
                         std::make_move_iterator(user_registered_cend()));
        m_separator = n;
        m_vector = std::move(new_cache);
      }

      /// Add a new element (by the user)
      template <class... Args>
      pdg_element const &add_user_element(Args &&... args) {
        pdg_element new_element{std::forward<Args>(args)...};
        auto e = end();
        if (std::find_if(begin(), e,
                         [this, &new_element](pdg_element const &el) {
                           return (el.name() == new_element.name() ||
                                   el.pdg_id() == new_element.pdg_id());
                         }) != e) {
          throw reactions::database_error(
              (std::string{"User-registered element clashes: \""} +
               new_element.name() + "\"")
                  .c_str());
        }
        m_vector.emplace_back(std::move(new_element));
        return m_vector.back();
      }

    protected:
      /// Collection of elements
      cache_type m_vector;

      /// Index that defines elements registered by the user and those read from
      /// the database
      size_type m_separator = 0;

    } m_cache; /// Cache for elements loaded from the database or registered by
               /// the user

    /// Open the database
    std::ifstream open_database() const {

      if (m_db.empty())
        throw reactions::database_error(
            "The PDG database has not been specified");

      std::ifstream file;

      try {
        file.open(m_db);
      } catch (...) {
        throw reactions::database_error("Unable to access the database");
      }

      if (!file.is_open())
        throw reactions::database_error("Unable to access the database");

      return file;
    }

    /// Skip lines with comments (preceeded by *)
    std::streampos skip_commented_lines(std::ifstream &file) const {

      char c;
      while (true) {
        file.get(c);
        if (c == '*')
          file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        else
          break;
      }
      file.unget();

      return file.tellg();
    }

    /// Read a field with the given index from a line
    template <std::size_t I>
    bool read_field(pdg_element::base_type &tuple,
                    std::string const &line) const {

      using field = std::tuple_element_t<I, pdg_element::fields>;

      if constexpr (database::is_optional_field_v<field>) {

        typename field::value_type::value_type value;

        auto sc = reactions::database::read_field<typename field::range_type>(
            value, line);

        if (sc == reactions::database::conversion_status::success)
          std::get<I>(tuple).emplace(value);

        return sc != reactions::database::conversion_status::failed;
      } else
        return reactions::database::read_field<typename field::range_type>(
                   std::get<I>(tuple), line) !=
               reactions::database::conversion_status::failed;
    }

    /// Read all the fields from a line
    template <std::size_t... I>
    bool read_line(pdg_element::base_type &tuple, std::string const &line,
                   std::index_sequence<I...>) const {
      return (read_field<I>(tuple, line) && ...);
    }

    /// Read all the fields from a line
    bool read_line(pdg_element::base_type &tuple,
                   std::string const &line) const {
      return read_line(
          tuple, line,
          std::make_index_sequence<pdg_element::number_of_fields>());
    }

    /// Advance to the next element in the file and read it
    pdg_element read_element(std::string const &line) const {

      pdg_element::base_type tuple;

      if (!read_line(tuple, line))
        throw reactions::database_error(
            "Error reading PDG database; data format not understood");

      return tuple;
    }

    /// Access an element using the field accessor
    template <class F, class T> pdg_element access(T const &v) const {

      switch (m_cache.status()) {
      case (cache::full): // the full database is loaded

        for (auto const &el : m_cache)
          if (el.get<F>() == v)
            return el;

        break; // throws an exception

      case (cache::user): // only user-registered entries exist

        for (auto const &el : m_cache)
          if (el.get<F>() == v)
            return el;

        [[fallthrough]]; // continue as if we had no cache

      case (cache::empty): // the cache is empty

        auto file = open_database();

        skip_commented_lines(file);

        std::string line;

        while (std::getline(file, line)) {

          typename F::value_type ref;
          auto sc = reactions::database::read_field<typename F::range_type>(
              ref, line);

          if (sc == reactions::database::failed)
            throw reactions::database_error(
                "Error reading PDG database; data format not understood");

          if (ref == v) {
            pdg_element el = read_element(line);
            file.close();
            return el;
          }
        }

        file.close();
      }

      throw reactions::lookup_error(
          (std::string{"Unable to find element with "} + F::title + " \"" +
           pdg::to_string(v) + '"')
              .c_str());
    }

    pdg_database() {}
    pdg_database(pdg_database &&) = delete;
    pdg_database(pdg_database const &) = delete;
    void operator=(pdg_database &&) = delete;
    void operator=(pdg_database const &) = delete;
  };
} // namespace reactions
