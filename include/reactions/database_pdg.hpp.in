/*! \file
  \brief Define elements to work with elements from the Particle Database Group
  (PDG) and manage the database service.
*/
#ifndef REACTIONS_PDG_HPP
#define REACTIONS_PDG_HPP

#include "reactions/database.hpp"
#include "reactions/exceptions.hpp"
#include "reactions/pow_enum.hpp"

#include <cmath>
#include <fstream>
#include <ios>
#include <limits>
#include <optional>
#include <stdexcept>
#include <tuple>
#include <vector>

namespace reactions::database_pdg {
  /// Forward declaration of the database type
  class database;
} // namespace reactions::database_pdg

/*! \brief PDG database and element
 */
namespace reactions::database_pdg {

  using double_opt = reactions::database::double_opt;

  /// Base class of a PDG particle
  using base_element =
      std::tuple<std::string, int, int, double_opt, double_opt, double_opt,
                 double_opt, double_opt, double_opt, bool>;

  /// Enumeration to access the PDG element fields
  REACTIONS_POW_ENUM_WITH_UNKNOWN(pdg_element_field, name, pdg_id, three_charge,
                                  mass, mass_error_lower, mass_error_upper,
                                  width, width_error_lower, width_error_upper,
                                  is_self_cc);

  /// Return the bounds defining a field in a line from the database file
  template <pdg_element_field E> struct bounds_for_field;
  template <> struct bounds_for_field<name> {
    static constexpr auto min = 0, max = 16;
  };
  template <> struct bounds_for_field<pdg_id> {
    static constexpr auto min = 17, max = 27;
  };
  template <> struct bounds_for_field<three_charge> {
    static constexpr auto min = 28, max = 30;
  };
  template <> struct bounds_for_field<mass> {
    static constexpr auto min = 31, max = 47;
  };
  template <> struct bounds_for_field<mass_error_lower> {
    static constexpr auto min = 48, max = 57;
  };
  template <> struct bounds_for_field<mass_error_upper> {
    static constexpr auto min = 58, max = 67;
  };
  template <> struct bounds_for_field<width> {
    static constexpr auto min = 68, max = 84;
  };
  template <> struct bounds_for_field<width_error_lower> {
    static constexpr auto min = 85, max = 94;
  };
  template <> struct bounds_for_field<width_error_upper> {
    static constexpr auto min = 95, max = 104;
  };
  template <> struct bounds_for_field<is_self_cc> {
    static constexpr auto min = 105, max = 106;
  };

  // Check that the number of fields and accessors are the same
  static_assert(pdg_element_field_properties::size ==
                std::tuple_size_v<base_element>);

  /// Definitions for internal use only
  namespace detail {

    template <pdg_element_field E>
    using field_t =
        std::tuple_element_t<pdg_element_field_properties::index<E>(),
                             base_element>;

    template <pdg_element_field E, class Enable = void>
    struct is_optional_field : std::false_type {};

    template <pdg_element_field E>
    struct is_optional_field<
        E, std::enable_if_t<reactions::database::is_optional_v<field_t<E>>>>
        : std::true_type {};

    template <pdg_element_field E>
    constexpr auto is_optional_field_v = is_optional_field<E>::value;

    template <class T> std::string to_string(T const &v) {
      return std::to_string(v);
    }

    template <> std::string to_string(std::string const &v) { return v; }
  } // namespace detail

  /*! \brief A PDG particle, based on the fields of a particle in the PDG
   * database.
   */
  class element : protected base_element {

  public:
    /// Base class
    using base_type = base_element;

    /// Number of data fields
    static const size_t nfields = std::tuple_size_v<base_type>;

    element() = delete;
    element(element const &) = default;
    element(element &&) = default;
    element &operator=(element const &) = default;
    element &operator=(element &&) = default;

    /// Construct the element from the contents
    element(base_type &&tuple) : base_type{std::move(tuple)} {}

    /// Assign the element from a tuple with the data fields
    element &operator=(base_type &&tup) {
      base_type::operator=(std::move(tup));
      return *this;
    }

    /// Compare the ID of the two particles
    bool operator==(element const &other) const {
      return pdg_id() == other.pdg_id();
    }

    /// Compare the ID of the two particles
    bool operator!=(element const &other) const {
      return pdg_id() != other.pdg_id();
    }

    /// Get an element using an accessor
    template <pdg_element_field E> auto const &get() const {
      if constexpr (detail::is_optional_field_v<E>)
        return std::get<pdg_element_field_properties::index<E>()>(*this)
            .value();
      else
        return std::get<pdg_element_field_properties::index<E>()>(*this);
    }

    /// Check whether
    template <pdg_element_field E> constexpr bool has() const {
      if constexpr (detail::is_optional_field_v<E>)
        return std::get<pdg_element_field_properties::index<E>()>(*this)
            .has_value();
      else
        return true;
    }

    /// Name of the particle
    std::string const &name() const { return get<pdg_element_field::name>(); }

    /// PDG ID
    int const &pdg_id() const { return get<pdg_element_field::pdg_id>(); }

    /// Three times the charge, as an integer
    int const &three_charge() const {
      return get<pdg_element_field::three_charge>();
    }

    /// Charge as a doubleing point number
    double charge() const {
      return get<pdg_element_field::three_charge>() / 3.;
    }

    /// Whether the element is its own charge-conjugate
    bool const &is_self_cc() const {
      return get<pdg_element_field::is_self_cc>();
    }

    /// Mass
    double const &mass() const { return get<pdg_element_field::mass>(); }

    /// Lower mass error
    double const &mass_error_lower() const {
      return get<pdg_element_field::mass_error_lower>();
    }

    /// Upper mass error
    double const &mass_error_upper() const {
      return get<pdg_element_field::mass_error_upper>();
    }

    /// Mass error
    double mass_error() const {

      if (!has<pdg_element_field::mass_error_lower>() ||
          !has<pdg_element_field::mass_error_upper>())
        throw reactions::exceptions::missing_fields_error(
            ("Unable to access mass errors; mass is not defined for particle" +
             name())
                .c_str());

      auto const el = get<pdg_element_field::mass_error_lower>();
      auto const eu = get<pdg_element_field::mass_error_upper>();

      return std::sqrt(el * el + eu * eu);
    }

    /// Width
    double const &width() const { return get<pdg_element_field::width>(); }

    /// Lower width error
    double const &width_error_lower() const {
      return get<pdg_element_field::width_error_lower>();
    }

    /// Upper width error
    double const &width_error_upper() const {
      return get<pdg_element_field::width_error_upper>();
    }

    /// Width error
    double width_error() const {

      if (!has<pdg_element_field::width_error_lower>() ||
          !has<pdg_element_field::width_error_upper>())
        throw reactions::exceptions::missing_fields_error(
            ("Unable to access width errors; width is not defined for "
             "particle" +
             name())
                .c_str());

      auto const el = get<pdg_element_field::width_error_lower>();
      auto const eu = get<pdg_element_field::width_error_upper>();

      return std::sqrt(el * el + eu * eu);
    }
  };

  /*! \brief Database of elements following the PDG convention
   *
   */
  class database {

  public:
    /// Disable the cache
    void disable_cache() { m_cache.clear(); }

    /* \brief Enable the internal cache.
     *
     * All the values in the database will be read an stored in a internal
     * cache. This will speed-up the code, with the caveat of consuming some
     * memory.
     */
    void enable_cache() {

      if (m_cache.size())
        return;

      auto file = open_database();

      std::string line;

      while (std::getline(file, line))
        m_cache.emplace_back(read_element(line));

      file.close();
    }

    /// Return the charge-conjugate of an element
    element cc(element const &el) const {

      if (el.is_self_cc())
        return el;
      else
        return operator()(-el.pdg_id());
    }

    /// Get the only instance of this class
    static database &instance() {
      static database db;
      return db;
    }

    /// Get the path to the database file
    std::string const &get_database_path() const { return m_db; }

    /* \brief Set the path to the database file.
     *
     * If the cache is enabled, reloads the content using the new path.
     */
    void set_database_path(std::string const &s) {
      m_db = s;
      if (m_cache.size()) {
        disable_cache();
        enable_cache();
      }
    }

    /// Create an element accessing by ID
    element operator()(int id) const {
      return access<pdg_element_field::pdg_id>(id);
    }

    /// Create an element accessing by name
    element operator()(std::string const &str) const {
      return access<pdg_element_field::name>(str);
    }

  private:
    /// Path to the database file
    std::string m_db = "@PDG_TABLE@";

    /// Possible cache for the elements
    std::vector<element> m_cache;

    /// Open the database
    std::ifstream open_database() const {

      if (m_db.empty())
        throw reactions::exceptions::database_error(
            "The PDG database has not been specified");

      std::ifstream file;

      try {
        file.open(m_db);
      } catch (...) {
        throw reactions::exceptions::database_error(
            "Unable to access the database");
      }

      if (!file.is_open())
        throw reactions::exceptions::database_error(
            "Unable to access the database");

      // skip comments
      char c;
      while (true) {
        file.get(c);
        if (c == '*')
          file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        else
          break;
      }
      file.unget();

      return file;
    }

    /// Read a field with the given index from a line
    template <std::size_t I>
    bool read_field(element::base_type &tuple, std::string const &line) const {

      static constexpr auto field = pdg_element_field_properties::list[I];
      static constexpr auto min = bounds_for_field<field>::min;
      static constexpr auto max = bounds_for_field<field>::max;

      if constexpr (detail::is_optional_field_v<field>) {

        typename std::tuple_element_t<I, element::base_type>::value_type value;

        auto sc = reactions::database::read_field<min, max>(value, line);

        if (sc == reactions::database::conversion_status::success)
          std::get<I>(tuple).emplace(value);

        return sc != reactions::database::conversion_status::failed;
      } else
        return reactions::database::read_field<min, max>(std::get<I>(tuple),
                                                         line) !=
               reactions::database::conversion_status::failed;
    }

    /// Read all the fields from a line
    template <std::size_t... I>
    bool read_line(element::base_type &tuple, std::string const &line,
                   std::index_sequence<I...>) const {
      return (read_field<I>(tuple, line) && ...);
    }

    /// Read all the fields from a line
    bool read_line(element::base_type &tuple, std::string const &line) const {
      return read_line(tuple, line,
                       std::make_index_sequence<element::nfields>());
    }

    /// Advance to the next element in the file and read it
    element read_element(std::string const &line) const {

      element::base_type tuple;

      if (!read_line(tuple, line))
        throw reactions::exceptions::database_error(
            "Error reading PDG database; data format not understood");

      return tuple;
    }

    /// Access an element using the field accessor
    template <pdg_element_field E, class T> element access(T const &v) const {

      if (m_cache.size()) {
        for (auto const &el : m_cache)
          if (el.get<E>() == v)
            return el;
      } else {

        auto file = open_database();

        std::string line;

        while (std::getline(file, line)) {

          // read only the important part
          static constexpr auto idx = pdg_element_field_properties::index<E>();
          static constexpr auto min = bounds_for_field<E>::min;
          static constexpr auto max = bounds_for_field<E>::max;
          std::tuple_element_t<idx, element::base_type> ref;
          auto sc = reactions::database::read_field<min, max>(ref, line);

          if (sc == reactions::database::failed)
            throw reactions::exceptions::database_error(
                "Error reading PDG database; data format not understood");

          if (ref == v) {
            element el = read_element(line);
            file.close();
            return el;
          }
        }

        file.close();
      }

      throw reactions::exceptions::lookup_error(
          (std::string{"Unable to find element with "} +
           pdg_element_field_properties::to_string(E) + " \"" +
           detail::to_string(v) + '"')
              .c_str());
    }

    database() {}
    database(database &&) = delete;
    database(database const &) = delete;
    void operator=(database const &other) = delete;
  };
} // namespace reactions::database_pdg

#endif // REACTIONS_PDG_HPP
