/*! \file
  \brief Define elements to work with elements from the Particle Database Group
  (PDG) and manage the database service.
*/
#ifndef REACTIONS_PDG_HPP
#define REACTIONS_PDG_HPP

#include "reactions/database.hpp"
#include "reactions/exceptions.hpp"
#include "reactions/pow_enum.hpp"

#include <cmath>
#include <fstream>
#include <ios>
#include <iostream>
#include <limits>
#include <optional>
#include <stdexcept>
#include <tuple>
#include <vector>

namespace reactions::database_pdg {
  /// Forward declaration of the database type
  class database;
} // namespace reactions::database_pdg

/*! \brief PDG database and element
 */
namespace reactions::database_pdg {

  using float_opt = reactions::database::float_opt;

  /// Base class of a PDG particle
  using base_element =
      std::tuple<std::string, int, int, float_opt, float_opt, float_opt,
                 float_opt, float_opt, float_opt, bool>;

  /// Enumeration to access the PDG element fields
  REACTIONS_POW_ENUM_WITH_UNKNOWN(pdg_element_field, name, pdg_id, three_charge,
                                  mass, mass_error_lower, mass_error_upper,
                                  width, width_error_lower, width_error_upper,
                                  is_self_cc);

  /// Return the bounds defining a field in a line from the database file
  template <pdg_element_field E> struct bounds_for_field;
  template <> struct bounds_for_field<name> {
    static constexpr auto min = 0, max = 16;
  };
  template <> struct bounds_for_field<pdg_id> {
    static constexpr auto min = 17, max = 27;
  };
  template <> struct bounds_for_field<three_charge> {
    static constexpr auto min = 28, max = 30;
  };
  template <> struct bounds_for_field<mass> {
    static constexpr auto min = 31, max = 47;
  };
  template <> struct bounds_for_field<mass_error_lower> {
    static constexpr auto min = 48, max = 57;
  };
  template <> struct bounds_for_field<mass_error_upper> {
    static constexpr auto min = 58, max = 67;
  };
  template <> struct bounds_for_field<width> {
    static constexpr auto min = 68, max = 84;
  };
  template <> struct bounds_for_field<width_error_lower> {
    static constexpr auto min = 85, max = 94;
  };
  template <> struct bounds_for_field<width_error_upper> {
    static constexpr auto min = 95, max = 104;
  };
  template <> struct bounds_for_field<is_self_cc> {
    static constexpr auto min = 105, max = 106;
  };

  // Check that the number of fields and accessors are the same
  static_assert(pdg_element_field_properties::size ==
                std::tuple_size_v<base_element>);

  /// Definitions for internal use only
  namespace detail {

    template <pdg_element_field E>
    using field_t =
        std::tuple_element_t<pdg_element_field_properties::index<E>(),
                             base_element>;

    template <pdg_element_field E, class Enable = void>
    struct is_optional_field : std::false_type {};

    template <pdg_element_field E>
    struct is_optional_field<
        E, std::enable_if_t<reactions::database::is_optional_v<field_t<E>>>>
        : std::true_type {};

    template <pdg_element_field E>
    constexpr auto is_optional_field_v = is_optional_field<E>::value;

    template <class T> std::string to_string(T const &v) {
      return std::to_string(v);
    }

    template <> std::string to_string(std::string const &v) { return v; }
  } // namespace detail

  /*! \brief A PDG particle, based on the fields of a particle in the PDG
   * database.
   */
  class element : protected base_element {

  public:
    /// Base class
    using base_type = base_element;

    /// Number of data fields
    static const size_t nfields = std::tuple_size_v<base_type>;

    /// Inherit constructors
    using base_type::base_type;

    /// Assign the element from a tuple with the data fields
    element &operator=(base_type &&tup) {
      base_type::operator=(std::move(tup));
      return *this;
    }

    /// Compare the ID of the two particles
    bool operator==(element const &other) const {
      return pdg_id() == other.pdg_id();
    }

    /// Compare the ID of the two particles
    bool operator!=(element const &other) const {
      return pdg_id() != other.pdg_id();
    }

    /// Get an element using an accessor
    template <pdg_element_field E> auto const &get() const {
      if constexpr (detail::is_optional_field_v<E>)
        return std::get<pdg_element_field_properties::index<E>()>(*this)
            .value();
      else
        return std::get<pdg_element_field_properties::index<E>()>(*this);
    }

    /// Check whether
    template <pdg_element_field E> constexpr bool has() const {
      if constexpr (detail::is_optional_field_v<E>)
        return std::get<pdg_element_field_properties::index<E>()>(*this)
            .has_value();
      else
        return true;
    }

    /// Name of the particle
    std::string const &name() const { return get<pdg_element_field::name>(); }

    /// PDG ID
    int const &pdg_id() const { return get<pdg_element_field::pdg_id>(); }

    /// Three times the charge, as an integer
    int const &three_charge() const {
      return get<pdg_element_field::three_charge>();
    }

    /// Charge as a floating point number
    float charge() const { return get<pdg_element_field::three_charge>() / 3.; }

    /// Whether the element is its own charge-conjugate
    bool const &is_self_cc() const {
      return get<pdg_element_field::is_self_cc>();
    }

    /// Mass
    float const &mass() const { return get<pdg_element_field::mass>(); }

    /// Lower mass error
    float const &mass_error_lower() const {
      return get<pdg_element_field::mass_error_lower>();
    }

    /// Upper mass error
    float const &mass_error_upper() const {
      return get<pdg_element_field::mass_error_upper>();
    }

    /// Mass error
    float mass_error() const {

      auto const el = has<pdg_element_field::mass_error_lower>()
                          ? get<pdg_element_field::mass_error_lower>()
                          : 0.f;
      auto const eu = has<pdg_element_field::mass_error_upper>()
                          ? get<pdg_element_field::mass_error_upper>()
                          : 0.f;

      return std::sqrt(el * el + eu * eu);
    }

    /// Width
    float const &width() const { return get<pdg_element_field::width>(); }

    /// Lower width error
    float const &width_error_lower() const {
      return get<pdg_element_field::width_error_lower>();
    }

    /// Upper width error
    float const &width_error_upper() const {
      return get<pdg_element_field::width_error_upper>();
    }

    /// Width error
    float width_error() const {

      auto const el = has<pdg_element_field::width_error_lower>()
                          ? get<pdg_element_field::width_error_lower>()
                          : 0.f;
      auto const eu = has<pdg_element_field::width_error_upper>()
                          ? get<pdg_element_field::width_error_upper>()
                          : 0.f;

      return std::sqrt(el * el + eu * eu);
    }

    template <std::size_t I> bool read_field(std::string const &line) {

      static constexpr auto field = pdg_element_field_properties::list[I];
      static constexpr auto min = bounds_for_field<field>::min;
      static constexpr auto max = bounds_for_field<field>::max;

      if constexpr (detail::is_optional_field_v<field>) {

        typename std::tuple_element_t<I, base_type>::value_type value;

        auto sc = reactions::database::read_field<min, max>(value, line);

        if (sc == reactions::database::conversion_status::success)
          std::get<I>(*this).emplace(value);

        return sc != reactions::database::conversion_status::failed;
      } else
        return reactions::database::read_field<min, max>(std::get<I>(*this),
                                                         line) !=
               reactions::database::conversion_status::failed;
    }

    template <std::size_t... I>
    bool read_line(std::string const &line, std::index_sequence<I...>) {
      return (read_field<I>(line) && ...);
    }

    bool operator<<(std::string const &line) {
      return read_line(line, std::make_index_sequence<nfields>());
    }
  };

  /*! \brief Database of elements following the PDG convention
   *
   */
  class database {

  public:
    /// Disable the cache
    void disable_cache() { m_cache.clear(); }

    /* \brief Enable the internal cache.
     *
     * All the values in the database will be read an stored in a internal
     * cache. This will speed-up the code, with the caveat of consuming some
     * memory.
     */
    void enable_cache() {

      if (m_cache.size())
        return;

      auto file = open_database();

      std::string line;

      while (std::getline(file, line)) {
        m_cache.emplace_back();
        read_element(m_cache.back(), line);
      }
      file.close();
    }

    /// Get the only instance of this class
    static database &instance() {
      static database db;
      return db;
    }

    /// Get the path to the database file
    std::string const &get_database_path() const { return m_db; }

    /* \brief Set the path to the database file.
     *
     * If the cache is enabled, reloads the content using the new path.
     */
    void set_database_path(std::string const &s) {
      m_db = s;
      if (m_cache.size()) {
        disable_cache();
        enable_cache();
      }
    }

    /// Create an element accessing by ID
    element operator()(int id) const {
      return access<pdg_element_field::pdg_id>(id);
    }

    /// Create an element accessing by name
    element operator()(std::string const &str) const {
      return access<pdg_element_field::name>(str);
    }

  private:
    /// Path to the database file
    std::string m_db = "@PDG_TABLE@";

    /// Possible cache for the elements
    std::vector<element> m_cache;

    /// Open the database
    std::ifstream open_database() const {

      if (m_db.empty())
        throw reactions::exceptions::database_error(
            "The PDG database has not been specified");

      std::ifstream file;
      file.open(m_db);
      if (!file.is_open())
        throw reactions::exceptions::database_error(
            "Unable to access the database");

      // skip comments
      char c;
      while (true) {
        file.get(c);
        if (c == '*')
          file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        else
          break;
      }
      file.unget();

      return file;
    }

    /// Advance to the next element in the file and read it
    void read_element(element &el, std::string const &line) const {

      if (!(el << line))
        throw reactions::exceptions::database_error(
            "Error reading PDG database; data format not understood");
    }

    /// Access an element using the field accessor
    template <pdg_element_field E, class T> element access(T const &v) const {

      if (m_cache.size()) {
        for (auto const &el : m_cache)
          if (el.get<E>() == v)
            return el;
      } else {

        auto file = open_database();

        std::string line;

        while (std::getline(file, line)) {
          element el;
          read_element(el, line);
          if (el.get<E>() == v) {
            file.close();
            return el;
          }
        }

        file.close();
      }

      throw reactions::exceptions::lookup_error(
          (std::string{"Unable to find element with "} +
           pdg_element_field_properties::to_string(E) + " \"" +
           detail::to_string(v) + '"')
              .c_str());
    }

    database() {}
    database(database &&) = delete;
    database(database const &) = delete;
    void operator=(database const &other) = delete;
  };
} // namespace reactions::database_pdg

#endif // REACTIONS_PDG_HPP
