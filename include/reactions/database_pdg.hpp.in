/*! \file
  \brief Define elements to work with elements from the Particle Database Group
  (PDG) and manage the database service.
*/
#ifndef REACTIONS_PDG_HPP
#define REACTIONS_PDG_HPP

#include "reactions/database.hpp"
#include "reactions/exceptions.hpp"
#include "reactions/pow_enum.hpp"

#include <cmath>
#include <fstream>
#include <ios>
#include <limits>
#include <optional>
#include <stdexcept>
#include <tuple>
#include <vector>

namespace reactions::database_pdg {
  /// Forward declaration of the database type
  class database;
} // namespace reactions::database_pdg

/*! \brief PDG database and element
 */
namespace reactions::database_pdg {

  using ve_double_opt = reactions::database::ve_double_opt;

  /// Define short structures that represent the fields of a \ref
  /// reactions::database_pdg::element object
  namespace detail {

    template <std::size_t Min, std::size_t Max>
    using range = reactions::database::range<Min, Max>;

    struct name {
      static constexpr const char *title = "name";
      using value_type = std::string;
      using range_type = range<0, 16>;
    };
    struct pdg_id {
      static constexpr const char *title = "pdg_id";
      using value_type = int;
      using range_type = range<17, 27>;
    };
    struct three_charge {
      static constexpr const char *title = "three_charge";
      using value_type = int;
      using range_type = range<28, 30>;
    };
    struct mass {
      static constexpr const char *title = "mass";
      using value_type = ve_double_opt;
      using range_type =
          std::tuple<range<31, 47>, range<48, 57>, range<58, 67>>;
    };
    struct width {
      static constexpr const char *title = "width";
      using value_type = ve_double_opt;
      using range_type =
          std::tuple<range<68, 84>, range<85, 94>, range<95, 104>>;
    };
    struct is_self_cc {
      static constexpr const char *title = "is_self_cc";
      using value_type = bool;
      using range_type = range<105, 106>;
    };

    /// Define a \ref std::tuple with the types of the fields provided
    template <class Tuple> struct underlying_types;

    template <class... F> struct underlying_types<std::tuple<F...>> {
      using type = std::tuple<typename F::value_type...>;
    };

    /// Base class of a PDG element
    struct base_element {
      using fields =
          std::tuple<name, pdg_id, three_charge, mass, width, is_self_cc>;
      using type = typename underlying_types<fields>::type;

      template <std::size_t I> using field_t = std::tuple_element_t<I, fields>;

      template <std::size_t I>
      using field_underlying_type_t = std::tuple_element_t<I, type>;

      template <std::size_t I, class F0, class F1> struct field_index_impl {
        static constexpr auto value = field_index_impl<
            I + 1, F0,
            std::tuple_element_t<I + 1, base_element::fields>>::value;
      };

      template <std::size_t I, class F> struct field_index_impl<I, F, F> {
        static constexpr auto value = I;
      };

      /// Get the index of a given field
      template <class F> struct field_index {
        static constexpr auto value = field_index_impl<
            0, F, std::tuple_element_t<0, base_element::fields>>::value;
      };

      template <class F>
      static constexpr auto field_index_v = field_index<F>::value;
    };

    /// Contain the information whether a field is optional or not
    template <class F, class Enable = void>
    struct is_optional_field : std::false_type {};

    /// Contain the information whether a field is optional or not
    template <class F>
    struct is_optional_field<
        F, std::enable_if_t<
               reactions::database::is_optional_v<typename F::value_type>>>
        : std::true_type {};

    /// Whether a field is optional or not
    template <class F>
    constexpr auto is_optional_field_v = is_optional_field<F>::value;

    /// Convert the given object to a string
    template <class T> std::string to_string(T const &v) {
      return std::to_string(v);
    }

    /// Convert the given object to a string
    template <> std::string to_string(std::string const &v) { return v; }
  } // namespace detail

  /*! \brief A PDG particle, based on the fields of a particle in the PDG
   * database.
   */
  class element : protected detail::base_element::type {

  public:
    /// Base class
    using base_type = detail::base_element::type;

    /// Number of data fields
    static const size_t nfields = std::tuple_size_v<base_type>;

    element() = delete;
    element(element const &) = default;
    element(element &&) = default;
    element &operator=(element const &) = default;
    element &operator=(element &&) = default;

    /// Construct the element from the contents
    element(base_type &&tuple) : base_type{std::move(tuple)} {}

    /// Assign the element from a tuple with the data fields
    element &operator=(base_type &&tup) {
      base_type::operator=(std::move(tup));
      return *this;
    }

    /// Compare the ID of the two particles
    bool operator==(element const &other) const {
      return pdg_id() == other.pdg_id();
    }

    /// Compare the ID of the two particles
    bool operator!=(element const &other) const {
      return pdg_id() != other.pdg_id();
    }

    /*! Get an element using an accessor.
     *
     * For fields of \ref std::optional type, the validity of the content
     * must be checked before calling this function using the
     * \ref element::has member function. Otherwise the
     * \ref reactions::exception::missing_fields_error exception is thrown,
     * if missing.
     */
    template <class F> auto const &get() const {
      if constexpr (detail::is_optional_field_v<F>)
        return std::get<detail::base_element::field_index_v<F>>(*this).value();
      else
        return std::get<detail::base_element::field_index_v<F>>(*this);
    }

    /// Check whether the given field information is missing or not
    template <class F> constexpr bool has() const {
      if constexpr (detail::is_optional_field_v<F>)
        return std::get<detail::base_element::field_index_v<F>>(*this)
            .has_value();
      else
        return true;
    }

    /// Name of the particle
    std::string const &name() const { return get<detail::name>(); }

    /// PDG ID
    int const &pdg_id() const { return get<detail::pdg_id>(); }

    /// Three times the charge, as an integer
    int const &three_charge() const { return get<detail::three_charge>(); }

    /// Charge as a doubleing point number
    double charge() const { return get<detail::three_charge>() / 3.; }

    /// Whether the element is its own charge-conjugate
    bool const &is_self_cc() const { return get<detail::is_self_cc>(); }

    /*! Get the mass of the element
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double const &mass() const { return get<detail::mass>().value; }

    /// Whether the mass and its errors are defined or not
    bool has_mass() const { return has<detail::mass>(); }

    /*! \brief Lower mass error
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double const &mass_error_lower() const {
      return get<detail::mass>().error_lower;
    }

    /*! \brief Upper mass error
     *
     * You must check whether the mass is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double const &mass_error_upper() const {
      return get<detail::mass>().error_upper;
    }

    /* \brief Calculate the mass error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double mass_error() const { return std::sqrt(mass_error_squared()); }

    /* \brief Calculate the mass error squared
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double mass_error_squared() const {

      if (!has<detail::mass>())
        throw reactions::exceptions::missing_fields_error(
            ("Unable to access mass errors; mass is not defined for particle" +
             name())
                .c_str());

      auto const el = mass_error_lower();
      auto const eu = mass_error_upper();

      return el * el + eu * eu;
    }

    /*! \brief Get the width of the element.
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double const &width() const { return get<detail::width>().value; }

    /// Whether the width and its errors are defined or not
    bool has_width() const { return has<detail::width>(); }

    /*! \brief Get the lower width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double const &width_error_lower() const {
      return get<detail::width>().error_lower;
    }

    /*! \brief Get the upper width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double const &width_error_upper() const {
      return get<detail::width>().error_upper;
    }

    /*! Calculate the width error
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double width_error() const { return std::sqrt(width_error_squared()); }

    /*! Calculate the width error squared
     *
     * You must check whether the width is defined or not before calling this
     * member function, otherwise a \ref
     * reactions::exceptions::missing_fields_error is thrown.
     */
    double width_error_squared() const {

      if (!has<detail::width>())
        throw reactions::exceptions::missing_fields_error(
            ("Unable to access width errors; width is not defined for "
             "particle" +
             name())
                .c_str());

      auto const el = width_error_lower();
      auto const eu = width_error_upper();

      return el * el + eu * eu;
    }
  };

  /*! \brief Database of elements following the PDG convention
   *
   */
  class database {

  public:
    /// Disable the cache
    void disable_cache() { m_cache.clear(); }

    /* \brief Enable the internal cache.
     *
     * All the values in the database will be read an stored in a internal
     * cache. This will speed-up the code, with the caveat of consuming some
     * memory.
     */
    void enable_cache() {

      if (m_cache.size())
        return;

      auto file = open_database();

      std::string line;

      while (std::getline(file, line))
        m_cache.emplace_back(read_element(line));

      file.close();
    }

    /// Return the charge-conjugate of an element
    element cc(element const &el) const {

      if (el.is_self_cc())
        return el;
      else
        return operator()(-el.pdg_id());
    }

    /// Get the only instance of this class
    static database &instance() {
      static database db;
      return db;
    }

    /// Get the path to the database file
    std::string const &get_database_path() const { return m_db; }

    /* \brief Set the path to the database file.
     *
     * If the cache is enabled, reloads the content using the new path.
     */
    void set_database_path(std::string const &s) {
      m_db = s;
      if (m_cache.size()) {
        disable_cache();
        enable_cache();
      }
    }

    /// Create an element accessing by ID
    element operator()(int id) const { return access<detail::pdg_id>(id); }

    /// Create an element accessing by name
    element operator()(std::string const &str) const {
      return access<detail::name>(str);
    }

  private:
    /// Path to the database file
    std::string m_db = "@PDG_TABLE@";

    /// Possible cache for the elements
    std::vector<element> m_cache;

    /// Open the database
    std::ifstream open_database() const {

      if (m_db.empty())
        throw reactions::exceptions::database_error(
            "The PDG database has not been specified");

      std::ifstream file;

      try {
        file.open(m_db);
      } catch (...) {
        throw reactions::exceptions::database_error(
            "Unable to access the database");
      }

      if (!file.is_open())
        throw reactions::exceptions::database_error(
            "Unable to access the database");

      // skip comments
      char c;
      while (true) {
        file.get(c);
        if (c == '*')
          file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        else
          break;
      }
      file.unget();

      return file;
    }

    /// Read a field with the given index from a line
    template <std::size_t I>
    bool read_field(element::base_type &tuple, std::string const &line) const {

      using field = detail::base_element::field_t<I>;

      if constexpr (detail::is_optional_field_v<field>) {

        typename field::value_type::value_type value;

        auto sc = reactions::database::read_field<typename field::range_type>(
            value, line);

        if (sc == reactions::database::conversion_status::success)
          std::get<I>(tuple).emplace(value);

        return sc != reactions::database::conversion_status::failed;
      } else
        return reactions::database::read_field<typename field::range_type>(
                   std::get<I>(tuple), line) !=
               reactions::database::conversion_status::failed;
    }

    /// Read all the fields from a line
    template <std::size_t... I>
    bool read_line(element::base_type &tuple, std::string const &line,
                   std::index_sequence<I...>) const {
      return (read_field<I>(tuple, line) && ...);
    }

    /// Read all the fields from a line
    bool read_line(element::base_type &tuple, std::string const &line) const {
      return read_line(tuple, line,
                       std::make_index_sequence<element::nfields>());
    }

    /// Advance to the next element in the file and read it
    element read_element(std::string const &line) const {

      element::base_type tuple;

      if (!read_line(tuple, line))
        throw reactions::exceptions::database_error(
            "Error reading PDG database; data format not understood");

      return tuple;
    }

    /// Access an element using the field accessor
    template <class F, class T> element access(T const &v) const {

      if (m_cache.size()) {
        for (auto const &el : m_cache)
          if (el.get<F>() == v)
            return el;
      } else {

        auto file = open_database();

        std::string line;

        while (std::getline(file, line)) {

          typename F::value_type ref;
          auto sc = reactions::database::read_field<typename F::range_type>(
              ref, line);

          if (sc == reactions::database::failed)
            throw reactions::exceptions::database_error(
                "Error reading PDG database; data format not understood");

          if (ref == v) {
            element el = read_element(line);
            file.close();
            return el;
          }
        }

        file.close();
      }

      throw reactions::exceptions::lookup_error(
          (std::string{"Unable to find element with "} + F::title + " \"" +
           detail::to_string(v) + '"')
              .c_str());
    }

    database() {}
    database(database &&) = delete;
    database(database const &) = delete;
    void operator=(database &&) = delete;
    void operator=(database const &) = delete;
  };
} // namespace reactions::database_pdg

#endif // REACTIONS_PDG_HPP
